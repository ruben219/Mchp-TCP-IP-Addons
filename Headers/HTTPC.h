/*	HTTP Client for Microchip's TCP/IP Stack
	Copyright (C) 2010 Jesus Ruben Santa Anna Zamudio.
	
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*This file has been prepared for Doxygen automatic documentation generation.*/

/**
@file HTTPC.h
@brief This is the header file for the HTTP Client for Microchip's TCP/IP Stack.
@ingroup <<<<PLACEHOLDER FOR CONTAINER GROUP>>>>
@defgroup HTTPC HTTP Client for Microchip's TCP/IP Stack

@code #include "HTTPC.h"@endcode
@par Overview
	<<<<PLACEHOLDER FOR FULL DESCRIPTION>>>>

@note <<<<PLACEHOLDER FOR NOTE>>>>

@par Requirements
	<<<<PLACEHOLDER FOR REQUIREMENTS>>>>

@par Usage
	<<<<PLACEHOLDER FOR USAGE INFORMATION>>>>
	@code foo = fooInitialize();@endcode
	<<<<PLACEHOLDER FOR USAGE INFORMATION>>>>
@warning <<<<PLACEHOLDER FOR WARNING MESSAGE>>>>

@author 	Jesus Ruben Santa Anna Zamudio.
@date		<<<<PLACEHOLDER FOR DATE>>>>
@version	<<<<PLACEHOLDER FOR VERSION>>>>
@todo		<<<<PLACEHOLDER FOR TODO INFO>>>>
*/

#ifndef HTTPC_H
#define HTTPC_H

/*-------------------------------------------------------------*/
/*				Includes and dependencies						*/
/*-------------------------------------------------------------*/

/*=============================================================*/
/*				Configuration and parameters					*/
/*=============================================================*/
#define CONFIG_HTTPC_SOCKET_PURPOSE					//!< Defines the purpose code used for the HTTP client, this is defined using the TCP/IP Wizzard
#define CONFIG_HTTPC_TCP_TXBUFFER_MAX		125u	//!< Maximum number of bytes that can be requested to transmit data
#define CONFIG_HTTPC_BUFFER_STATUS_LINE		1		//!< Defines if the client should buffer the response line
#define CONFIG_HTTPC_RESPLINE_BUFFER		50		//!< Minimum of 15 characters is recomended to buffer the protocol version and HTTP/1.0 200
/*=============================================================*/
/* End of configuration, do not touch anything below this line 	*/
/*=============================================================*/

/*-------------------------------------------------------------*/
/*				Macros and definitions							*/
/*-------------------------------------------------------------*/

/*-------------------------------------------------------------*/
/*				Typedefs enums & structs						*/
/*-------------------------------------------------------------*/
/** This enumetation defines the HTTP methods supported by the embedded HTTP client. */
enum HttpMethodsEnum
{
	E_HTTP_GET = 0,
	E_HTTP_POST,
	E_HTTP_PUT,
	E_HTTP_DELETE,
};

/** This structure holds the data needed to communicate with the server and perform a request*/
struct HttpcRequest
{
	enum HttpMethodsEnum eMethod;	//!< HTTP Method used for the request
	BYTE *	Server;					//!< Server to which the request is directed
	WORD	ServerPort;				//!< Server's port
	BYTE *	pcUrl;					//!< Uniform Resource Locator
	BYTE *	ReqData;				//!< Request Body Data
	WORD	ReqDataLength;			//!< Request Body Data Length
	BYTE *	AdditionalHeaders;		//!< Pointer to aditional header string to be transmitted
	BYTE *	ResponseBuffer;			//!< Pointer to buffer to hold the received data
	BYTE	ResponseBufferLength;	//!< Space available on the receive buffer
};

/** This enumeration defines the error codes generated by the HTTP client, please note that this enumetation is NOT
related to the HTTP protocol status and error codes.*/
enum HttpcErrorsEnum
{
	E_HTTPC_ERROR_NONE = 0,			//!< No client errors occurred during HTTP request
	E_HTTPC_ERROR_SOCKET,			//!< Cannot obtain http client socket
	E_HTTPC_ERROR_REQ_DATA,			//!< Missformed or incomplete request structure
	E_HTTPC_ERROR_METHOD,			//!< Method not implemented
	E_HTTPC_ERROR_CON_TIMEOUT,		//!< Timeout while connecting to server
	E_HTTPC_ERROR_ACT_TIMEOUT,		//!< Timeout due to server/client inactivity
	E_HTTPC_ERROR_TXOVERFLOW,		//!< Headers or data to be sent exceed the available buffer
	E_HTTPC_ERROR_RXOVERFLOW,		//!< Headers or received data unit exeed the available buffer
};
/*-------------------------------------------------------------*/
/*				Function prototypes								*/
/*-------------------------------------------------------------*/
void HttpClientTask();
BOOL HttpcBeginUsage();
void HttpcEndUsage();
enum HttpcErrorsEnum HttpcGetError();
BOOL HttpcRequestDone();
BOOL HttpcRequest( struct HttpcRequest * HttpReqData );
BOOL HttpcProcessResponse(BYTE * ReceivedData, WORD DataCount);
#endif
// End of Header file

/* Usage Examples */

/*
struct HttpRequest TaskReqData;	// Structure to hold server and buffer data

void TaskExUsingHttpc()
{
	static unsigned char SensorValue1 = 0, SensorValue2 = 0;
	static BYTE RequestBody[45];	// UrlEncoded, XML, CVS, Text, etc.
	
	static enum TaskExHttp{ E_TASKEX_COLLECT_DATA, E_TASKEX_START_REQ, E_TASKEX_FIN_REQ } eTaskState = E_TASKEX_COLLECT_DATA;
	
	switch(eTaskState)
	{
		case E_TASKEX_COLLECT_DATA:
			if(TaskExConditionMet())	// A condition or event triggers state machine to the next state
			{
				SensorValue1 = SampleSensor(0x90);	// Do some preparation
				SensorValue2 = SampleSensor(0x92);
				sprintf(RequestBody, "Temperature1,%d\r\nTemperature2,%d\r\n", SensorValue1, SensorValue2);
				eTaskState++;
			}
		break;
		
		case E_TASKEX_START_REQ:
			if(HttpcBeginUsage())	// Take control of the HTTP client
			{
				// Fill the request structure and begin request to server
				HttpPutRequest(&TaskReqData, (ROM BYTE *)"tech-freaks.net", (ROM BYTE *)"index.php", NULL);
				HttpcRequest(&TaskReqData);
				eTaskState++;
			}
		break;
		case E_TASKEX_PROCESS_HEADERS:
			HttpcDataAck();		// Ignore Headers
			if(HttpcHeadersReceived())
				eTaskState++;
		break;
		
		case E_TASKEX_PROCESS_RESPONSE:
			WORD datardy = HttpcAvailable();
			if(datardy != 0)
				UartPut(&ResponseBuffer, datardy);
			HttpcDataAck();		// Http client can now copy new data to the provided buffer
			if(HttpcRequestDone())
				eTaskState++;
		break;
		
		
		case E_TASKEX_FIN_REQ:
			if(HttpcRequestDone())
			{
				enum HttpcErrorsEnum ErrorCode = HttpcGetError();
				if(ErrorCode)
					putsUART("Client Error occurred during request");	
				HttpcEndUsage();
			}
		break;
}

*/
